/*
 * Copyright (C) 2017 by TS Sundquist
 * 
 * All rights reserved.
 * 
 */

package sundquis.core;

import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

import sundquis.core.test.CaseResult;
import sundquis.core.test.ClassResult;
import sundquis.core.test.MemberResult;
import sundquis.core.test.Result;
import sundquis.core.test.TestCaseImpl;
import sundquis.core.test.TestResult;
import sundquis.util.PriorityQueue;
import sundquis.util.Queue;

/**
 * Work Flow
 * 		Annotate members of target class to indicate a test case
 * 		Copy stub into container class
 * 		Implement test case; indicate results using TestCase
 * 
 * Evaluation:
 * 		public static class SomeContainer implements Test.Container {
 * 
 * 			@Override
 * 			public Class<?> subjectClass() {
 * 				return MyApplication.class;
 * 			}
 * 
 * 			// Copied stubs, implemented
 * 			// Implementations use API presented by TestCase interface
 * 			@Impl( ... )
 * 			public void subj_Description( TestCase tc ) {
 * 				tc.pass()
 * 			}
 * 
 * 		}
 * 
 * 		new Test( SomeContainer.class ).eval();
 * 
 * 		[ repeat for additional application classes ]
 * 
 * 		Test.printResults(); 
 * 
 * Feedback:
 * 		Un-annotated elements generate warnings per the policy defined by properties in test.Results
 * 		Declared test cases without implementations generate stubs for container
 * 		Implementations without declarations (orphans) generate warnings
 * 		Results show multi-level summaries as specified by properties in test.Results
 * 
 */
@Test.Decl( "Loads correctly" )
public class Test {
	
	
	/**
	 * Annotate class elements (containing class, member class, constructor, field, method)
	 * to declare a test case pertaining to the element.
	 */
	@Test.Skip
	@Repeatable( Decls.class )
	@Retention( RetentionPolicy.RUNTIME )
	@Target( {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE} )
	public @interface Decl {

		/**
		 * A brief description of the test case. It is used to generate the name of the 
		 * corresponding test method.
		 */
		String value();
		
	}
	
	/**
	 * Container for repeated test declarations
	 */
	@Test.Skip
	@Retention( RetentionPolicy.RUNTIME )
	@Target( {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE} )
	public @interface Decls {
		Decl[] value();
	}
	
	/**
	 * Marker for test implementation methods. These are generated by the test framework and generally
	 * should not be hand. In particular the {@code src} and {@code desc} fields are generated to 
	 * correspond to a target test declaration.
	 * 
	 * The optional numeric fields may be included to adjust features of the test.
	 */
	@Test.Skip
	@Retention( RetentionPolicy.RUNTIME )
	@Target( ElementType.METHOD )
	public @interface Impl {

		/** Do not edit. Must match the corresponding declaration */
		String src();
		
		/** Do not edit. Must match the corresponding declaration */
		String desc();

		/** CURRENTLY NOT USED */
		long timeout() default 0L;
		
		/** Used to control the order of execution of test methods */
		int priority() default 0;
		
		/** Used to scale the relative importance of the test case */
		int weight() default 1;
		
	}
	

	/**
	 * Used to indicate that the element (and contained elements if a class) should not
	 * be scanned for test cases. Can be used to mark simple components that do not require
	 * testing or components that are externally tested.
	 * 
	 * The optional string {@code value} can be used to describe alternate testing
	 */
	@Test.Skip
	@Retention( RetentionPolicy.RUNTIME )
	@Target( {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE} )
	public @interface Skip {
		
		String value() default "No test";
		
	}

	
	
	


	// Tree of results for all classes being tested
	private static final TestResult testResult = new TestResult();

	// Elements (MemberResult) that have no test declarations or (TestRunner) classes without containers
	private static Collection<String> warnings = new TreeSet<String>();
	
	private static boolean showWarnings = true;
	
	private static class Stub {
		private String member;
		private String description;
		private String subject;
		
		Stub( String member, String description, String subject ) {
			this.member = member;
			this.description = description;
			this.subject = subject;
		}
		
		@Override
		@Test.Skip
		public String toString() {
			String mname = Strings.toCamelCase( this.description );
			StringBuilder s = new StringBuilder();
			s.append( "@Test.Impl( src = \"" + this.member + "\", desc = \"" + this.description + "\" )\n" );
			s.append( "public void " + this.subject + "_" + mname + "( TestCase tc ) {\n" );
			s.append( "\ttc.addMessage( \"Unimplemented\" ).fail();\n" );
			s.append( "}\n" );
			return s.toString();
		}
	}
	
	private static final List<Stub> stubs = new LinkedList<Stub>();
	
	private static boolean showStubs = true;
	
	/**
	 * Print results from all tests.
	 * 
	 * Once this method has been called no subsequent results will be recorded so this should
	 * only be called after all tests finish.
	 */
	@Test.Skip
	public static void printResults() {
		System.out.println();
		
		Test.testResult.print( "" );
		System.err.println();
		System.err.flush();

		if ( Test.showWarnings ) {
			System.out.println( "\n\nWARNINGS:" );
			for ( String s : Test.warnings ) {
				System.out.println( "\t" + s );
			}
		}

		if ( Test.showStubs ) {
			System.out.println( "\nSTUBS:" );
			for ( Stub s : Test.stubs) {
				System.out.println( s );
			}
		}
	}
	
	/**
	 * Suppress all warnings.
	 */
	@Test.Skip
	public static void noWarnings() {
		Test.showWarnings = false;
	}

	/**
	 * Add a non-empty warning message.
	 */
	@Decl( "Throws assertion error if warning is null" )
	@Decl( "Throws assertion error if warning is empty" )
	public static void addWarning( String warning ) {
		Assert.nonEmpty( warning );
		
		synchronized ( Test.warnings ) {
			Test.warnings.add( warning );
		}
	}
	
	@Skip
	public static void noStubs() {
		Test.showStubs = false;
	}

	@Decl( "Throws assertion error if member is empty" )
	@Decl( "Throws assertion error if descrption is empty" )
	@Decl( "Throws assertion error if subject is empty" )
	public static void addStub( String member, String description, String subject ) {
		Assert.nonEmpty( member );
		Assert.nonEmpty( description );
		Assert.nonEmpty( subject );

		Test.stubs.add( new Stub( member, description, subject ) );
	}

	/**
	 * Show only the top-level summary, class-level summary, and failure messages
	 */
	@Test.Skip
	public static void summaryOnly() {
		Result.summary();
	}
	
	
	

	// Holds test methods for the subject class
	private TestContainer container;
	
	// Results associated with test cases for the associated subject class
	private final ClassResult classResult;
	
	// Map from member.desription key to corresponding Case
	// This combination is assumed to be unique over all test cases
	// This constraint is enforced by the naming conventions in te MemberResult constructors
	private final Map<String, CaseResult> caseResults;
	
	// Queue of TestCase instances awaiting evaluation.
	private final Queue<TestCaseImpl> queue;

	@Decl( "Throws assertion error for null container" )
	@Decl( "Fails for containers with illegal constructors" )
	public Test( Class<? extends TestContainer> containerClass ) {
		Assert.nonNull( containerClass );
		
		try {
			this.container = containerClass.newInstance();
		} catch ( Exception e ) {
			Fatal.error( "Failed to construct Test Container", e );
		}
		this.classResult = Test.testResult.addClass( this.container.subjectClass() );
		this.caseResults = new TreeMap<String, CaseResult>();
		this.queue = new PriorityQueue<TestCaseImpl>();

		this.scan( this.container.subjectClass() );
		this.loadContainer();
	}

	// The container has implementations of test methods. Use reflection to find them and
	// enqueue TestCase jobs
	private void loadContainer() {
		this.container.beforeAll().call();
		
		Method[] methods = this.container.getClass().getDeclaredMethods();
		for ( Method method : methods ) {
			this.addTestCase( method, method.getAnnotation( Impl.class ) );
		}
		this.queue.close();
	}
	
	@Decl( "Handles cases in priority order." )
	public void eval() {
		TestCaseImpl tc;
		while ( (tc = this.queue.get()) != null ) {
			// Not designed to be executed concurrently but could be run in a separate thread 
			// and monitored. In that case shold consult the Test.Impl.timeout() value
			tc.run();  
		}
		this.container.afterAll().call();

		System.out.println( this.classResult );
	}
	
	private void addTestCase( Method method, Impl impl ) {
		// The container may have various non-test methods
		if ( impl == null ) {
			return;
		}
		
		CaseResult cr = this.caseResults.get( impl.src() + "." + impl.desc() );
		
		// Can happen when Test.Decl is deleted, or when a method name changes
		if ( cr == null ) {
			Test.addWarning( "Orphaned test case: " + impl.src() + ", " + impl.desc() );
			return;
		}

		this.queue.put( new TestCaseImpl( impl, this.container, method, cr ) );
	}

	private void scan( Class<?> clazz ) {
		MemberResult mr = this.classResult.addMember( clazz );
		if ( ! mr.include() ) {
			return;
		}
		this.addAnnotations( mr );
		
		Constructor<?>[] constructors = clazz.getDeclaredConstructors();
		for ( Constructor<?> constructor : constructors ) {
			if ( ! constructor.isSynthetic() ) {
				mr = this.classResult.addMember( constructor );
				if ( mr.include() ) {
					this.addAnnotations( mr );
				}
			}
		}
		
		Field[] fields = clazz.getDeclaredFields();
		for ( Field field : fields ) {
			if ( ! field.isSynthetic() ) {
				mr = this.classResult.addMember( field );
				if ( mr.include() ) {
					this.addAnnotations( mr );
				}
			}
		}
		
		Method[] methods = clazz.getDeclaredMethods();
		for ( Method method : methods ) {
			if ( ! method.isSynthetic() && ! "main".equals( method.getName() ) ) {
				mr = this.classResult.addMember( method );
				if ( mr.include() ) {
					this.addAnnotations( mr );
				}
			}
		}
		
		Class<?>[] classes = clazz.getDeclaredClasses();
		for ( Class<?> c : classes ) {
			if ( ! TestContainer.class.isAssignableFrom( c ) ) {
				this.scan( c );
			}
		}
	}

	@Decl( "Description's with; puc-tuation! handled... right?" )
	@Decl( "Can change name of generated method" )
	private void addAnnotations( MemberResult mr ) {
		Decl[] declarations = mr.getAnnotations();
		for ( Decl d : declarations ) {
			if ( d.value().isEmpty() ) {
				Fatal.error( "Missing description on annotation for " + mr );
			}
			
			CaseResult cr = mr.addCase( d );
			this.caseResults.put( cr.getKey(), cr );
		}
	}
	
	
	
	
	
	public static class Container implements TestContainer {
		
		@Override
		public Class<?> subjectClass() {
			return Test.class;
		}
		
		
		@Test.Impl( src = "Test", desc = "Loads correctly" )
		public void Test_LoadsCorrectly( TestCase tc ) {
			tc.addMessage( "Manually verified" ).pass();
		}

		@Test.Impl( src = "private void Test.addAnnotations(MemberResult)", desc = "Can change name of generated method" )
		public void addAnnotations_CanChangeNameOfGeneratedMethod( TestCase tc ) {
			tc.addMessage( "Manually verified" ).pass();
		}

		@Test.Impl( src = "private void Test.addAnnotations(MemberResult)", desc = "Description's with; puc-tuation! handled... right?" )
		public void addAnnotations_DescriptionSWithPucTuationHandledRight( TestCase tc ) {
			tc.addMessage( "Manually verified" ).pass();
		}

		
		
		public static class BadContainer implements TestContainer {

			BadContainer() {}
			
			@Override
			public Class<?> subjectClass() {
				return null;
			}
			
		}
		
		@Test.Impl( src = "public Test(Class)", desc = "Fails for containers with illegal constructors" )
		public void Test_FailsForContainersWithIllegalConstructors( TestCase tc ) {
			tc.expectError( AssertionError.class );
			new Test( BadContainer.class );
		}

		@Test.Impl( src = "public Test(Class)", desc = "Throws assertion error for null container" )
		public void Test_ThrowsAssertionErrorForNullContainer( TestCase tc ) {
			tc.expectError( AssertionError.class );
			new Test( null );
		}

		@Test.Impl( src = "public void Test.addStub(String, String, String)", desc = "Throws assertion error if descrption is empty" )
		public void addStub_TrhowsAssertionErrorIfDescrptionIsEmpty( TestCase tc ) {
			tc.expectError( AssertionError.class );
			Test.addStub( "", "Hello", "World" );
		}

		@Test.Impl( src = "public void Test.addStub(String, String, String)", desc = "Throws assertion error if member is empty" )
		public void addStub_TrhowsAssertionErrorIfMemberIsEmpty( TestCase tc ) {
			tc.expectError( AssertionError.class );
			Test.addStub( "Hello", "", "World" );
		}

		@Test.Impl( src = "public void Test.addStub(String, String, String)", desc = "Throws assertion error if subject is empty" )
		public void addStub_TrhowsAssertionErrorIfSubjectIsEmpty( TestCase tc ) {
			tc.expectError( AssertionError.class );
			Test.addStub( "Hello", "World", "" );
		}

		@Test.Impl( src = "public void Test.addWarning(String)", desc = "Throws assertion error if warning is empty" )
		public void addWarning_ThrowsAssertionErrorIfWarningIsEmpty( TestCase tc ) {
			tc.expectError( AssertionError.class );
			Test.addWarning( "" );
		}

		@Test.Impl( src = "public void Test.addWarning(String)", desc = "Throws assertion error if warning is null" )
		public void addWarning_ThrowsAssertionErrorIfWarningIsNull( TestCase tc ) {
			tc.expectError( AssertionError.class );
			Test.addWarning( null );
		}

		@Test.Impl( src = "public void Test.eval()", desc = "Handles cases in priority order." )
		public void eval_HandlesCasesInPriorityOrder( TestCase tc ) {
			tc.addMessage( "Manually verified" ).pass();
		}
		
		
		
	}
	
	
	public static void main(String[] args) {
		System.out.println();
		
		new Test( Container.class ).eval();
		Test.printResults();

		System.out.println("\nDone!");
	}
	
}
